{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/yoiker/Downloads/TechReboot2.65/TechReboot/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getDistance, getLinkColor, getRandom, getRangeValue, rangeColorToRgb } from \"@tsparticles/engine\";\nimport { drawLinkLine, drawLinkTriangle, setLinkFrequency } from \"./Utils.js\";\nconst minOpacity = 0,\n  minWidth = 0,\n  minDistance = 0,\n  half = 0.5,\n  maxFrequency = 1;\nexport class LinkInstance {\n  constructor(container, engine) {\n    this._drawLinkLine = (p1, link) => {\n      const p1LinksOptions = p1.options.links;\n      if (!p1LinksOptions?.enable) {\n        return;\n      }\n      const container = this._container,\n        options = container.actualOptions,\n        p2 = link.destination,\n        pos1 = p1.getPosition(),\n        pos2 = p2.getPosition();\n      let opacity = link.opacity;\n      container.canvas.draw(ctx => {\n        let colorLine;\n        const twinkle = p1.options.twinkle?.lines;\n        if (twinkle?.enable) {\n          const twinkleFreq = twinkle.frequency,\n            twinkleRgb = rangeColorToRgb(this._engine, twinkle.color),\n            twinkling = getRandom() < twinkleFreq;\n          if (twinkling && twinkleRgb) {\n            colorLine = twinkleRgb;\n            opacity = getRangeValue(twinkle.opacity);\n          }\n        }\n        if (!colorLine) {\n          const linkColor = p1LinksOptions.id !== undefined ? container.particles.linksColors.get(p1LinksOptions.id) : container.particles.linksColor;\n          colorLine = getLinkColor(p1, p2, linkColor);\n        }\n        if (!colorLine) {\n          return;\n        }\n        const width = p1.retina.linksWidth ?? minWidth,\n          maxDistance = p1.retina.linksDistance ?? minDistance,\n          {\n            backgroundMask\n          } = options;\n        drawLinkLine({\n          context: ctx,\n          width,\n          begin: pos1,\n          end: pos2,\n          engine: this._engine,\n          maxDistance,\n          canvasSize: container.canvas.size,\n          links: p1LinksOptions,\n          backgroundMask: backgroundMask,\n          colorLine,\n          opacity\n        });\n      });\n    };\n    this._drawLinkTriangle = (p1, link1, link2) => {\n      const linksOptions = p1.options.links;\n      if (!linksOptions?.enable) {\n        return;\n      }\n      const triangleOptions = linksOptions.triangles;\n      if (!triangleOptions.enable) {\n        return;\n      }\n      const container = this._container,\n        options = container.actualOptions,\n        p2 = link1.destination,\n        p3 = link2.destination,\n        opacityTriangle = triangleOptions.opacity ?? (link1.opacity + link2.opacity) * half;\n      if (opacityTriangle <= minOpacity) {\n        return;\n      }\n      container.canvas.draw(ctx => {\n        const pos1 = p1.getPosition(),\n          pos2 = p2.getPosition(),\n          pos3 = p3.getPosition(),\n          linksDistance = p1.retina.linksDistance ?? minDistance;\n        if (getDistance(pos1, pos2) > linksDistance || getDistance(pos3, pos2) > linksDistance || getDistance(pos3, pos1) > linksDistance) {\n          return;\n        }\n        let colorTriangle = rangeColorToRgb(this._engine, triangleOptions.color);\n        if (!colorTriangle) {\n          const linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n          colorTriangle = getLinkColor(p1, p2, linkColor);\n        }\n        if (!colorTriangle) {\n          return;\n        }\n        drawLinkTriangle({\n          context: ctx,\n          pos1,\n          pos2,\n          pos3,\n          backgroundMask: options.backgroundMask,\n          colorTriangle,\n          opacityTriangle\n        });\n      });\n    };\n    this._drawTriangles = (options, p1, link, p1Links) => {\n      const p2 = link.destination;\n      if (!(options.links?.triangles.enable && p2.options.links?.triangles.enable)) {\n        return;\n      }\n      const vertices = p2.links?.filter(t => {\n        const linkFreq = this._getLinkFrequency(p2, t.destination),\n          minCount = 0;\n        return p2.options.links && linkFreq <= p2.options.links.frequency && p1Links.findIndex(l => l.destination === t.destination) >= minCount;\n      });\n      if (!vertices?.length) {\n        return;\n      }\n      for (const vertex of vertices) {\n        const p3 = vertex.destination,\n          triangleFreq = this._getTriangleFrequency(p1, p2, p3);\n        if (triangleFreq > options.links.triangles.frequency) {\n          continue;\n        }\n        this._drawLinkTriangle(p1, link, vertex);\n      }\n    };\n    this._getLinkFrequency = (p1, p2) => {\n      return setLinkFrequency([p1, p2], this._freqs.links);\n    };\n    this._getTriangleFrequency = (p1, p2, p3) => {\n      return setLinkFrequency([p1, p2, p3], this._freqs.triangles);\n    };\n    this._container = container;\n    this._engine = engine;\n    this._freqs = {\n      links: new Map(),\n      triangles: new Map()\n    };\n  }\n  drawParticle(context, particle) {\n    const {\n      links,\n      options\n    } = particle;\n    if (!links?.length) {\n      return;\n    }\n    const p1Links = links.filter(l => options.links && (options.links.frequency >= maxFrequency || this._getLinkFrequency(particle, l.destination) <= options.links.frequency));\n    for (const link of p1Links) {\n      this._drawTriangles(options, particle, link, p1Links);\n      if (link.opacity > minOpacity && (particle.retina.linksWidth ?? minWidth) > minWidth) {\n        this._drawLinkLine(particle, link);\n      }\n    }\n  }\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._freqs.links = new Map();\n      _this._freqs.triangles = new Map();\n      yield Promise.resolve();\n    })();\n  }\n  particleCreated(particle) {\n    particle.links = [];\n    if (!particle.options.links) {\n      return;\n    }\n    const ratio = this._container.retina.pixelRatio,\n      {\n        retina\n      } = particle,\n      {\n        distance,\n        width\n      } = particle.options.links;\n    retina.linksDistance = distance * ratio;\n    retina.linksWidth = width * ratio;\n  }\n  particleDestroyed(particle) {\n    particle.links = [];\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}