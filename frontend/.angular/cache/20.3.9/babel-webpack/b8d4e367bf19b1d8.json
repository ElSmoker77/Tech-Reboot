{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/yoiker/Downloads/TechReboot2.64/TechReboot/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { canvasFirstIndex, canvasTag, errorPrefix, generatedAttribute, generatedFalse, generatedTrue, loadMinIndex, loadRandomFactor, none, one, removeDeleteCount } from \"./Utils/Constants.js\";\nimport { executeOnSingleOrMultiple, getLogger, itemFromSingleOrMultiple } from \"../Utils/Utils.js\";\nimport { Container } from \"./Container.js\";\nimport { EventDispatcher } from \"../Utils/EventDispatcher.js\";\nimport { EventType } from \"../Enums/Types/EventType.js\";\nimport { getRandom } from \"../Utils/NumberUtils.js\";\nfunction getItemsFromInitializer(_x, _x2, _x3) {\n  return _getItemsFromInitializer.apply(this, arguments);\n}\nfunction _getItemsFromInitializer() {\n  _getItemsFromInitializer = _asyncToGenerator(function* (container, map, initializers, force = false) {\n    let res = map.get(container);\n    if (!res || force) {\n      res = yield Promise.all([...initializers.values()].map(t => t(container)));\n      map.set(container, res);\n    }\n    return res;\n  });\n  return _getItemsFromInitializer.apply(this, arguments);\n}\nfunction getDataFromUrl(_x4) {\n  return _getDataFromUrl.apply(this, arguments);\n}\nfunction _getDataFromUrl() {\n  _getDataFromUrl = _asyncToGenerator(function* (data) {\n    const url = itemFromSingleOrMultiple(data.url, data.index);\n    if (!url) {\n      return data.fallback;\n    }\n    const response = yield fetch(url);\n    if (response.ok) {\n      return yield response.json();\n    }\n    getLogger().error(`${errorPrefix} ${response.status} while retrieving config file`);\n    return data.fallback;\n  });\n  return _getDataFromUrl.apply(this, arguments);\n}\nconst getCanvasFromContainer = domContainer => {\n    let canvasEl;\n    if (domContainer instanceof HTMLCanvasElement || domContainer.tagName.toLowerCase() === canvasTag) {\n      canvasEl = domContainer;\n      if (!canvasEl.dataset[generatedAttribute]) {\n        canvasEl.dataset[generatedAttribute] = generatedFalse;\n      }\n    } else {\n      const existingCanvases = domContainer.getElementsByTagName(canvasTag);\n      if (existingCanvases.length) {\n        canvasEl = existingCanvases[canvasFirstIndex];\n        canvasEl.dataset[generatedAttribute] = generatedFalse;\n      } else {\n        canvasEl = document.createElement(canvasTag);\n        canvasEl.dataset[generatedAttribute] = generatedTrue;\n        domContainer.appendChild(canvasEl);\n      }\n    }\n    const fullPercent = \"100%\";\n    if (!canvasEl.style.width) {\n      canvasEl.style.width = fullPercent;\n    }\n    if (!canvasEl.style.height) {\n      canvasEl.style.height = fullPercent;\n    }\n    return canvasEl;\n  },\n  getDomContainer = (id, source) => {\n    let domContainer = source ?? document.getElementById(id);\n    if (domContainer) {\n      return domContainer;\n    }\n    domContainer = document.createElement(\"div\");\n    domContainer.id = id;\n    domContainer.dataset[generatedAttribute] = generatedTrue;\n    document.body.append(domContainer);\n    return domContainer;\n  };\nexport class Engine {\n  constructor() {\n    this._configs = new Map();\n    this._domArray = [];\n    this._eventDispatcher = new EventDispatcher();\n    this._initialized = false;\n    this.plugins = [];\n    this.colorManagers = new Map();\n    this.easingFunctions = new Map();\n    this._initializers = {\n      interactors: new Map(),\n      movers: new Map(),\n      updaters: new Map()\n    };\n    this.interactors = new Map();\n    this.movers = new Map();\n    this.updaters = new Map();\n    this.presets = new Map();\n    this.effectDrawers = new Map();\n    this.shapeDrawers = new Map();\n    this.pathGenerators = new Map();\n  }\n  get configs() {\n    const res = {};\n    for (const [name, config] of this._configs) {\n      res[name] = config;\n    }\n    return res;\n  }\n  get items() {\n    return this._domArray;\n  }\n  get version() {\n    return \"3.9.1\";\n  }\n  addColorManager(_x5) {\n    var _this = this;\n    return _asyncToGenerator(function* (manager, refresh = true) {\n      _this.colorManagers.set(manager.key, manager);\n      yield _this.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addConfig(config) {\n    const key = config.key ?? config.name ?? \"default\";\n    this._configs.set(key, config);\n    this._eventDispatcher.dispatchEvent(EventType.configAdded, {\n      data: {\n        name: key,\n        config\n      }\n    });\n  }\n  addEasing(_x6, _x7) {\n    var _this2 = this;\n    return _asyncToGenerator(function* (name, easing, refresh = true) {\n      if (_this2.getEasing(name)) {\n        return;\n      }\n      _this2.easingFunctions.set(name, easing);\n      yield _this2.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addEffect(_x8, _x9) {\n    var _this3 = this;\n    return _asyncToGenerator(function* (effect, drawer, refresh = true) {\n      executeOnSingleOrMultiple(effect, type => {\n        if (!_this3.getEffectDrawer(type)) {\n          _this3.effectDrawers.set(type, drawer);\n        }\n      });\n      yield _this3.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addEventListener(type, listener) {\n    this._eventDispatcher.addEventListener(type, listener);\n  }\n  addInteractor(_x0, _x1) {\n    var _this4 = this;\n    return _asyncToGenerator(function* (name, interactorInitializer, refresh = true) {\n      _this4._initializers.interactors.set(name, interactorInitializer);\n      yield _this4.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addMover(_x10, _x11) {\n    var _this5 = this;\n    return _asyncToGenerator(function* (name, moverInitializer, refresh = true) {\n      _this5._initializers.movers.set(name, moverInitializer);\n      yield _this5.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addParticleUpdater(_x12, _x13) {\n    var _this6 = this;\n    return _asyncToGenerator(function* (name, updaterInitializer, refresh = true) {\n      _this6._initializers.updaters.set(name, updaterInitializer);\n      yield _this6.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addPathGenerator(_x14, _x15) {\n    var _this7 = this;\n    return _asyncToGenerator(function* (name, generator, refresh = true) {\n      if (!_this7.getPathGenerator(name)) {\n        _this7.pathGenerators.set(name, generator);\n      }\n      yield _this7.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addPlugin(_x16) {\n    var _this8 = this;\n    return _asyncToGenerator(function* (plugin, refresh = true) {\n      if (!_this8.getPlugin(plugin.id)) {\n        _this8.plugins.push(plugin);\n      }\n      yield _this8.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addPreset(_x17, _x18) {\n    var _this9 = this;\n    return _asyncToGenerator(function* (preset, options, override = false, refresh = true) {\n      if (override || !_this9.getPreset(preset)) {\n        _this9.presets.set(preset, options);\n      }\n      yield _this9.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  addShape(_x19) {\n    var _this0 = this;\n    return _asyncToGenerator(function* (drawer, refresh = true) {\n      for (const validType of drawer.validTypes) {\n        if (_this0.getShapeDrawer(validType)) {\n          continue;\n        }\n        _this0.shapeDrawers.set(validType, drawer);\n      }\n      yield _this0.refresh(refresh);\n    }).apply(this, arguments);\n  }\n  checkVersion(pluginVersion) {\n    if (this.version === pluginVersion) {\n      return;\n    }\n    throw new Error(`The tsParticles version is different from the loaded plugins version. Engine version: ${this.version}. Plugin version: ${pluginVersion}`);\n  }\n  clearPlugins(container) {\n    this.updaters.delete(container);\n    this.movers.delete(container);\n    this.interactors.delete(container);\n  }\n  dispatchEvent(type, args) {\n    this._eventDispatcher.dispatchEvent(type, args);\n  }\n  dom() {\n    return this.items;\n  }\n  domItem(index) {\n    return this.item(index);\n  }\n  getAvailablePlugins(container) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      const res = new Map();\n      for (const plugin of _this1.plugins) {\n        if (plugin.needsPlugin(container.actualOptions)) {\n          res.set(plugin.id, yield plugin.getPlugin(container));\n        }\n      }\n      return res;\n    })();\n  }\n  getEasing(name) {\n    return this.easingFunctions.get(name) ?? (value => value);\n  }\n  getEffectDrawer(type) {\n    return this.effectDrawers.get(type);\n  }\n  getInteractors(_x20) {\n    var _this10 = this;\n    return _asyncToGenerator(function* (container, force = false) {\n      return getItemsFromInitializer(container, _this10.interactors, _this10._initializers.interactors, force);\n    }).apply(this, arguments);\n  }\n  getMovers(_x21) {\n    var _this11 = this;\n    return _asyncToGenerator(function* (container, force = false) {\n      return getItemsFromInitializer(container, _this11.movers, _this11._initializers.movers, force);\n    }).apply(this, arguments);\n  }\n  getPathGenerator(type) {\n    return this.pathGenerators.get(type);\n  }\n  getPlugin(plugin) {\n    return this.plugins.find(t => t.id === plugin);\n  }\n  getPreset(preset) {\n    return this.presets.get(preset);\n  }\n  getShapeDrawer(type) {\n    return this.shapeDrawers.get(type);\n  }\n  getSupportedEffects() {\n    return this.effectDrawers.keys();\n  }\n  getSupportedShapes() {\n    return this.shapeDrawers.keys();\n  }\n  getUpdaters(_x22) {\n    var _this12 = this;\n    return _asyncToGenerator(function* (container, force = false) {\n      return getItemsFromInitializer(container, _this12.updaters, _this12._initializers.updaters, force);\n    }).apply(this, arguments);\n  }\n  init() {\n    if (this._initialized) {\n      return;\n    }\n    this._initialized = true;\n  }\n  item(index) {\n    const {\n        items\n      } = this,\n      item = items[index];\n    if (!item || item.destroyed) {\n      items.splice(index, removeDeleteCount);\n      return;\n    }\n    return item;\n  }\n  load(params) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const id = params.id ?? params.element?.id ?? `tsparticles${Math.floor(getRandom() * loadRandomFactor)}`,\n        {\n          index,\n          url\n        } = params,\n        options = url ? yield getDataFromUrl({\n          fallback: params.options,\n          url,\n          index\n        }) : params.options,\n        currentOptions = itemFromSingleOrMultiple(options, index),\n        {\n          items\n        } = _this13,\n        oldIndex = items.findIndex(v => v.id.description === id),\n        newItem = new Container(_this13, id, currentOptions);\n      if (oldIndex >= loadMinIndex) {\n        const old = _this13.item(oldIndex),\n          deleteCount = old ? one : none;\n        if (old && !old.destroyed) {\n          old.destroy(false);\n        }\n        items.splice(oldIndex, deleteCount, newItem);\n      } else {\n        items.push(newItem);\n      }\n      const domContainer = getDomContainer(id, params.element),\n        canvasEl = getCanvasFromContainer(domContainer);\n      newItem.canvas.loadCanvas(canvasEl);\n      yield newItem.start();\n      return newItem;\n    })();\n  }\n  loadOptions(options, sourceOptions) {\n    this.plugins.forEach(plugin => plugin.loadOptions?.(options, sourceOptions));\n  }\n  loadParticlesOptions(container, options, ...sourceOptions) {\n    const updaters = this.updaters.get(container);\n    if (!updaters) {\n      return;\n    }\n    updaters.forEach(updater => updater.loadOptions?.(options, ...sourceOptions));\n  }\n  refresh() {\n    var _this14 = this;\n    return _asyncToGenerator(function* (refresh = true) {\n      if (!refresh) {\n        return;\n      }\n      yield Promise.all(_this14.items.map(t => t.refresh()));\n    }).apply(this, arguments);\n  }\n  removeEventListener(type, listener) {\n    this._eventDispatcher.removeEventListener(type, listener);\n  }\n  setOnClickHandler(callback) {\n    const {\n      items\n    } = this;\n    if (!items.length) {\n      throw new Error(`${errorPrefix} can only set click handlers after calling tsParticles.load()`);\n    }\n    items.forEach(item => item.addClickHandler(callback));\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}