{"ast":null,"code":"import { AnimationStatus, DestroyType, RotateDirection, degToRad, getRandom, getRangeValue, updateAnimation } from \"@tsparticles/engine\";\nimport { Rotate } from \"./Options/Classes/Rotate.js\";\nconst double = 2,\n  doublePI = Math.PI * double,\n  identity = 1,\n  doublePIDeg = 360;\nexport class RotateUpdater {\n  constructor(container) {\n    this.container = container;\n  }\n  init(particle) {\n    const rotateOptions = particle.options.rotate;\n    if (!rotateOptions) {\n      return;\n    }\n    particle.rotate = {\n      enable: rotateOptions.animation.enable,\n      value: degToRad(getRangeValue(rotateOptions.value)),\n      min: 0,\n      max: doublePI\n    };\n    particle.pathRotation = rotateOptions.path;\n    let rotateDirection = rotateOptions.direction;\n    if (rotateDirection === RotateDirection.random) {\n      const index = Math.floor(getRandom() * double),\n        minIndex = 0;\n      rotateDirection = index > minIndex ? RotateDirection.counterClockwise : RotateDirection.clockwise;\n    }\n    switch (rotateDirection) {\n      case RotateDirection.counterClockwise:\n      case \"counterClockwise\":\n        particle.rotate.status = AnimationStatus.decreasing;\n        break;\n      case RotateDirection.clockwise:\n        particle.rotate.status = AnimationStatus.increasing;\n        break;\n    }\n    const rotateAnimation = rotateOptions.animation;\n    if (rotateAnimation.enable) {\n      particle.rotate.decay = identity - getRangeValue(rotateAnimation.decay);\n      particle.rotate.velocity = getRangeValue(rotateAnimation.speed) / doublePIDeg * this.container.retina.reduceFactor;\n      if (!rotateAnimation.sync) {\n        particle.rotate.velocity *= getRandom();\n      }\n    }\n    particle.rotation = particle.rotate.value;\n  }\n  isEnabled(particle) {\n    const rotate = particle.options.rotate;\n    if (!rotate) {\n      return false;\n    }\n    return !particle.destroyed && !particle.spawning && (!!rotate.value || rotate.animation.enable || rotate.path);\n  }\n  loadOptions(options, ...sources) {\n    if (!options.rotate) {\n      options.rotate = new Rotate();\n    }\n    for (const source of sources) {\n      options.rotate.load(source?.rotate);\n    }\n  }\n  update(particle, delta) {\n    if (!this.isEnabled(particle)) {\n      return;\n    }\n    particle.isRotating = !!particle.rotate;\n    if (!particle.rotate) {\n      return;\n    }\n    updateAnimation(particle, particle.rotate, false, DestroyType.none, delta);\n    particle.rotation = particle.rotate.value;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}