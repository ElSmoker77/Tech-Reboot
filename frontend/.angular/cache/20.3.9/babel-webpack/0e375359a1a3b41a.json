{"ast":null,"code":"import { getRangeValue, hslToRgb, hslaToRgba, parseAlpha } from \"@tsparticles/engine\";\nvar HslIndexes = /*#__PURE__*/function (HslIndexes) {\n  HslIndexes[HslIndexes[\"h\"] = 1] = \"h\";\n  HslIndexes[HslIndexes[\"s\"] = 2] = \"s\";\n  HslIndexes[HslIndexes[\"l\"] = 3] = \"l\";\n  HslIndexes[HslIndexes[\"a\"] = 5] = \"a\";\n  return HslIndexes;\n}(HslIndexes || {});\nexport class HslColorManager {\n  constructor() {\n    this.key = \"hsl\";\n    this.stringPrefix = \"hsl\";\n  }\n  handleColor(color) {\n    const colorValue = color.value,\n      hslColor = colorValue.hsl ?? color.value;\n    if (hslColor.h !== undefined && hslColor.s !== undefined && hslColor.l !== undefined) {\n      return hslToRgb(hslColor);\n    }\n  }\n  handleRangeColor(color) {\n    const colorValue = color.value,\n      hslColor = colorValue.hsl ?? color.value;\n    if (hslColor.h !== undefined && hslColor.l !== undefined) {\n      return hslToRgb({\n        h: getRangeValue(hslColor.h),\n        l: getRangeValue(hslColor.l),\n        s: getRangeValue(hslColor.s)\n      });\n    }\n  }\n  parseString(input) {\n    if (!input.startsWith(\"hsl\")) {\n      return;\n    }\n    const regex = /hsla?\\(\\s*(\\d+)\\s*[\\s,]\\s*(\\d+)%\\s*[\\s,]\\s*(\\d+)%\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i,\n      result = regex.exec(input),\n      minLength = 4,\n      defaultAlpha = 1,\n      radix = 10;\n    return result ? hslaToRgba({\n      a: result.length > minLength ? parseAlpha(result[HslIndexes.a]) : defaultAlpha,\n      h: parseInt(result[HslIndexes.h], radix),\n      l: parseInt(result[HslIndexes.l], radix),\n      s: parseInt(result[HslIndexes.s], radix)\n    }) : undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}