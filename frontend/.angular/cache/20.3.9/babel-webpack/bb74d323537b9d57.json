{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ALUMNO/Downloads/TechReboot2.55/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { animate, cancelAnimation, getRangeValue } from \"../Utils/NumberUtils.js\";\nimport { clickRadius, defaultFps, defaultFpsLimit, errorPrefix, millisecondsToSeconds, minCoordinate, minFpsLimit, removeDeleteCount, removeMinIndex, touchEndLengthOffset } from \"./Utils/Constants.js\";\nimport { getLogger, safeIntersectionObserver } from \"../Utils/Utils.js\";\nimport { Canvas } from \"./Canvas.js\";\nimport { EventListeners } from \"./Utils/EventListeners.js\";\nimport { EventType } from \"../Enums/Types/EventType.js\";\nimport { Options } from \"../Options/Classes/Options.js\";\nimport { Particles } from \"./Particles.js\";\nimport { Retina } from \"./Retina.js\";\nimport { loadOptions } from \"../Utils/OptionsUtils.js\";\nfunction guardCheck(container) {\n  return container && !container.destroyed;\n}\nfunction initDelta(value, fpsLimit = defaultFps, smooth = false) {\n  return {\n    value,\n    factor: smooth ? defaultFps / fpsLimit : defaultFps * value / millisecondsToSeconds\n  };\n}\nfunction loadContainerOptions(engine, container, ...sourceOptionsArr) {\n  const options = new Options(engine, container);\n  loadOptions(options, ...sourceOptionsArr);\n  return options;\n}\nexport class Container {\n  constructor(engine, id, sourceOptions) {\n    this._intersectionManager = entries => {\n      if (!guardCheck(this) || !this.actualOptions.pauseOnOutsideViewport) {\n        return;\n      }\n      for (const entry of entries) {\n        if (entry.target !== this.interactivity.element) {\n          continue;\n        }\n        if (entry.isIntersecting) {\n          void this.play();\n        } else {\n          this.pause();\n        }\n      }\n    };\n    this._nextFrame = timestamp => {\n      try {\n        if (!this._smooth && this._lastFrameTime !== undefined && timestamp < this._lastFrameTime + millisecondsToSeconds / this.fpsLimit) {\n          this.draw(false);\n          return;\n        }\n        this._lastFrameTime ??= timestamp;\n        const delta = initDelta(timestamp - this._lastFrameTime, this.fpsLimit, this._smooth);\n        this.addLifeTime(delta.value);\n        this._lastFrameTime = timestamp;\n        if (delta.value > millisecondsToSeconds) {\n          this.draw(false);\n          return;\n        }\n        this.particles.draw(delta);\n        if (!this.alive()) {\n          this.destroy();\n          return;\n        }\n        if (this.animationStatus) {\n          this.draw(false);\n        }\n      } catch (e) {\n        getLogger().error(`${errorPrefix} in animation loop`, e);\n      }\n    };\n    this._engine = engine;\n    this.id = Symbol(id);\n    this.fpsLimit = 120;\n    this._smooth = false;\n    this._delay = 0;\n    this._duration = 0;\n    this._lifeTime = 0;\n    this._firstStart = true;\n    this.started = false;\n    this.destroyed = false;\n    this._paused = true;\n    this._lastFrameTime = 0;\n    this.zLayers = 100;\n    this.pageHidden = false;\n    this._clickHandlers = new Map();\n    this._sourceOptions = sourceOptions;\n    this._initialSourceOptions = sourceOptions;\n    this.retina = new Retina(this);\n    this.canvas = new Canvas(this, this._engine);\n    this.particles = new Particles(this._engine, this);\n    this.pathGenerators = new Map();\n    this.interactivity = {\n      mouse: {\n        clicking: false,\n        inside: false\n      }\n    };\n    this.plugins = new Map();\n    this.effectDrawers = new Map();\n    this.shapeDrawers = new Map();\n    this._options = loadContainerOptions(this._engine, this);\n    this.actualOptions = loadContainerOptions(this._engine, this);\n    this._eventListeners = new EventListeners(this);\n    this._intersectionObserver = safeIntersectionObserver(entries => this._intersectionManager(entries));\n    this._engine.dispatchEvent(EventType.containerBuilt, {\n      container: this\n    });\n  }\n  get animationStatus() {\n    return !this._paused && !this.pageHidden && guardCheck(this);\n  }\n  get options() {\n    return this._options;\n  }\n  get sourceOptions() {\n    return this._sourceOptions;\n  }\n  addClickHandler(callback) {\n    if (!guardCheck(this)) {\n      return;\n    }\n    const el = this.interactivity.element;\n    if (!el) {\n      return;\n    }\n    const clickOrTouchHandler = (e, pos, radius) => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        const pxRatio = this.retina.pixelRatio,\n          posRetina = {\n            x: pos.x * pxRatio,\n            y: pos.y * pxRatio\n          },\n          particles = this.particles.quadTree.queryCircle(posRetina, radius * pxRatio);\n        callback(e, particles);\n      },\n      clickHandler = e => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        const mouseEvent = e,\n          pos = {\n            x: mouseEvent.offsetX || mouseEvent.clientX,\n            y: mouseEvent.offsetY || mouseEvent.clientY\n          };\n        clickOrTouchHandler(e, pos, clickRadius);\n      },\n      touchStartHandler = () => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        touched = true;\n        touchMoved = false;\n      },\n      touchMoveHandler = () => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        touchMoved = true;\n      },\n      touchEndHandler = e => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        if (touched && !touchMoved) {\n          const touchEvent = e;\n          let lastTouch = touchEvent.touches[touchEvent.touches.length - touchEndLengthOffset];\n          if (!lastTouch) {\n            lastTouch = touchEvent.changedTouches[touchEvent.changedTouches.length - touchEndLengthOffset];\n            if (!lastTouch) {\n              return;\n            }\n          }\n          const element = this.canvas.element,\n            canvasRect = element ? element.getBoundingClientRect() : undefined,\n            pos = {\n              x: lastTouch.clientX - (canvasRect ? canvasRect.left : minCoordinate),\n              y: lastTouch.clientY - (canvasRect ? canvasRect.top : minCoordinate)\n            };\n          clickOrTouchHandler(e, pos, Math.max(lastTouch.radiusX, lastTouch.radiusY));\n        }\n        touched = false;\n        touchMoved = false;\n      },\n      touchCancelHandler = () => {\n        if (!guardCheck(this)) {\n          return;\n        }\n        touched = false;\n        touchMoved = false;\n      };\n    let touched = false,\n      touchMoved = false;\n    this._clickHandlers.set(\"click\", clickHandler);\n    this._clickHandlers.set(\"touchstart\", touchStartHandler);\n    this._clickHandlers.set(\"touchmove\", touchMoveHandler);\n    this._clickHandlers.set(\"touchend\", touchEndHandler);\n    this._clickHandlers.set(\"touchcancel\", touchCancelHandler);\n    for (const [key, handler] of this._clickHandlers) {\n      el.addEventListener(key, handler);\n    }\n  }\n  addLifeTime(value) {\n    this._lifeTime += value;\n  }\n  addPath(key, generator, override = false) {\n    if (!guardCheck(this) || !override && this.pathGenerators.has(key)) {\n      return false;\n    }\n    this.pathGenerators.set(key, generator);\n    return true;\n  }\n  alive() {\n    return !this._duration || this._lifeTime <= this._duration;\n  }\n  clearClickHandlers() {\n    if (!guardCheck(this)) {\n      return;\n    }\n    for (const [key, handler] of this._clickHandlers) {\n      this.interactivity.element?.removeEventListener(key, handler);\n    }\n    this._clickHandlers.clear();\n  }\n  destroy(remove = true) {\n    if (!guardCheck(this)) {\n      return;\n    }\n    this.stop();\n    this.clearClickHandlers();\n    this.particles.destroy();\n    this.canvas.destroy();\n    for (const effectDrawer of this.effectDrawers.values()) {\n      effectDrawer.destroy?.(this);\n    }\n    for (const shapeDrawer of this.shapeDrawers.values()) {\n      shapeDrawer.destroy?.(this);\n    }\n    for (const key of this.effectDrawers.keys()) {\n      this.effectDrawers.delete(key);\n    }\n    for (const key of this.shapeDrawers.keys()) {\n      this.shapeDrawers.delete(key);\n    }\n    this._engine.clearPlugins(this);\n    this.destroyed = true;\n    if (remove) {\n      const mainArr = this._engine.items,\n        idx = mainArr.findIndex(t => t === this);\n      if (idx >= removeMinIndex) {\n        mainArr.splice(idx, removeDeleteCount);\n      }\n    }\n    this._engine.dispatchEvent(EventType.containerDestroyed, {\n      container: this\n    });\n  }\n  draw(force) {\n    if (!guardCheck(this)) {\n      return;\n    }\n    let refreshTime = force;\n    const frame = timestamp => {\n      if (refreshTime) {\n        this._lastFrameTime = undefined;\n        refreshTime = false;\n      }\n      this._nextFrame(timestamp);\n    };\n    this._drawAnimationFrame = animate(timestamp => frame(timestamp));\n  }\n  export(_x) {\n    var _this = this;\n    return _asyncToGenerator(function* (type, options = {}) {\n      for (const plugin of _this.plugins.values()) {\n        if (!plugin.export) {\n          continue;\n        }\n        const res = yield plugin.export(type, options);\n        if (!res.supported) {\n          continue;\n        }\n        return res.blob;\n      }\n      getLogger().error(`${errorPrefix} - Export plugin with type ${type} not found`);\n    }).apply(this, arguments);\n  }\n  handleClickMode(mode) {\n    if (!guardCheck(this)) {\n      return;\n    }\n    this.particles.handleClickMode(mode);\n    for (const plugin of this.plugins.values()) {\n      plugin.handleClickMode?.(mode);\n    }\n  }\n  init() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!guardCheck(_this2)) {\n        return;\n      }\n      const effects = _this2._engine.getSupportedEffects();\n      for (const type of effects) {\n        const drawer = _this2._engine.getEffectDrawer(type);\n        if (drawer) {\n          _this2.effectDrawers.set(type, drawer);\n        }\n      }\n      const shapes = _this2._engine.getSupportedShapes();\n      for (const type of shapes) {\n        const drawer = _this2._engine.getShapeDrawer(type);\n        if (drawer) {\n          _this2.shapeDrawers.set(type, drawer);\n        }\n      }\n      yield _this2.particles.initPlugins();\n      _this2._options = loadContainerOptions(_this2._engine, _this2, _this2._initialSourceOptions, _this2.sourceOptions);\n      _this2.actualOptions = loadContainerOptions(_this2._engine, _this2, _this2._options);\n      const availablePlugins = yield _this2._engine.getAvailablePlugins(_this2);\n      for (const [id, plugin] of availablePlugins) {\n        _this2.plugins.set(id, plugin);\n      }\n      _this2.retina.init();\n      yield _this2.canvas.init();\n      _this2.updateActualOptions();\n      _this2.canvas.initBackground();\n      _this2.canvas.resize();\n      const {\n        zLayers,\n        duration,\n        delay,\n        fpsLimit,\n        smooth\n      } = _this2.actualOptions;\n      _this2.zLayers = zLayers;\n      _this2._duration = getRangeValue(duration) * millisecondsToSeconds;\n      _this2._delay = getRangeValue(delay) * millisecondsToSeconds;\n      _this2._lifeTime = 0;\n      _this2.fpsLimit = fpsLimit > minFpsLimit ? fpsLimit : defaultFpsLimit;\n      _this2._smooth = smooth;\n      for (const drawer of _this2.effectDrawers.values()) {\n        yield drawer.init?.(_this2);\n      }\n      for (const drawer of _this2.shapeDrawers.values()) {\n        yield drawer.init?.(_this2);\n      }\n      for (const plugin of _this2.plugins.values()) {\n        yield plugin.init?.();\n      }\n      _this2._engine.dispatchEvent(EventType.containerInit, {\n        container: _this2\n      });\n      yield _this2.particles.init();\n      _this2.particles.setDensity();\n      for (const plugin of _this2.plugins.values()) {\n        plugin.particlesSetup?.();\n      }\n      _this2._engine.dispatchEvent(EventType.particlesSetup, {\n        container: _this2\n      });\n    })();\n  }\n  loadTheme(name) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!guardCheck(_this3)) {\n        return;\n      }\n      _this3._currentTheme = name;\n      yield _this3.refresh();\n    })();\n  }\n  pause() {\n    if (!guardCheck(this)) {\n      return;\n    }\n    if (this._drawAnimationFrame !== undefined) {\n      cancelAnimation(this._drawAnimationFrame);\n      delete this._drawAnimationFrame;\n    }\n    if (this._paused) {\n      return;\n    }\n    for (const plugin of this.plugins.values()) {\n      plugin.pause?.();\n    }\n    if (!this.pageHidden) {\n      this._paused = true;\n    }\n    this._engine.dispatchEvent(EventType.containerPaused, {\n      container: this\n    });\n  }\n  play(force) {\n    if (!guardCheck(this)) {\n      return;\n    }\n    const needsUpdate = this._paused || force;\n    if (this._firstStart && !this.actualOptions.autoPlay) {\n      this._firstStart = false;\n      return;\n    }\n    if (this._paused) {\n      this._paused = false;\n    }\n    if (needsUpdate) {\n      for (const plugin of this.plugins.values()) {\n        if (plugin.play) {\n          plugin.play();\n        }\n      }\n    }\n    this._engine.dispatchEvent(EventType.containerPlay, {\n      container: this\n    });\n    this.draw(needsUpdate ?? false);\n  }\n  refresh() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!guardCheck(_this4)) {\n        return;\n      }\n      _this4.stop();\n      return _this4.start();\n    })();\n  }\n  reset(sourceOptions) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!guardCheck(_this5)) {\n        return;\n      }\n      _this5._initialSourceOptions = sourceOptions;\n      _this5._sourceOptions = sourceOptions;\n      _this5._options = loadContainerOptions(_this5._engine, _this5, _this5._initialSourceOptions, _this5.sourceOptions);\n      _this5.actualOptions = loadContainerOptions(_this5._engine, _this5, _this5._options);\n      return _this5.refresh();\n    })();\n  }\n  start() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (!guardCheck(_this6) || _this6.started) {\n        return;\n      }\n      yield _this6.init();\n      _this6.started = true;\n      yield new Promise(resolve => {\n        const start = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* () {\n            _this6._eventListeners.addListeners();\n            if (_this6.interactivity.element instanceof HTMLElement && _this6._intersectionObserver) {\n              _this6._intersectionObserver.observe(_this6.interactivity.element);\n            }\n            for (const plugin of _this6.plugins.values()) {\n              yield plugin.start?.();\n            }\n            _this6._engine.dispatchEvent(EventType.containerStarted, {\n              container: _this6\n            });\n            _this6.play();\n            resolve();\n          });\n          return function start() {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        _this6._delayTimeout = setTimeout(() => void start(), _this6._delay);\n      });\n    })();\n  }\n  stop() {\n    if (!guardCheck(this) || !this.started) {\n      return;\n    }\n    if (this._delayTimeout) {\n      clearTimeout(this._delayTimeout);\n      delete this._delayTimeout;\n    }\n    this._firstStart = true;\n    this.started = false;\n    this._eventListeners.removeListeners();\n    this.pause();\n    this.particles.clear();\n    this.canvas.stop();\n    if (this.interactivity.element instanceof HTMLElement && this._intersectionObserver) {\n      this._intersectionObserver.unobserve(this.interactivity.element);\n    }\n    for (const plugin of this.plugins.values()) {\n      plugin.stop?.();\n    }\n    for (const key of this.plugins.keys()) {\n      this.plugins.delete(key);\n    }\n    this._sourceOptions = this._options;\n    this._engine.dispatchEvent(EventType.containerStopped, {\n      container: this\n    });\n  }\n  updateActualOptions() {\n    this.actualOptions.responsive = [];\n    const newMaxWidth = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options);\n    this.actualOptions.setTheme(this._currentTheme);\n    if (this._responsiveMaxWidth === newMaxWidth) {\n      return false;\n    }\n    this._responsiveMaxWidth = newMaxWidth;\n    return true;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}