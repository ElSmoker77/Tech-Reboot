{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/yoiker/Downloads/TechReboot2.65/TechReboot/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AnimationStatus, DestroyType, degToRad, getRandom, getRangeValue, half, updateAnimation } from \"@tsparticles/engine\";\nimport { Tilt } from \"./Options/Classes/Tilt.js\";\nimport { TiltDirection } from \"./TiltDirection.js\";\nconst identity = 1,\n  double = 2,\n  doublePI = Math.PI * double,\n  maxAngle = 360;\nexport class TiltUpdater {\n  constructor(container) {\n    this.container = container;\n  }\n  getTransformValues(particle) {\n    const tilt = particle.tilt?.enable && particle.tilt;\n    return {\n      b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : undefined,\n      c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : undefined\n    };\n  }\n  init(particle) {\n    const tiltOptions = particle.options.tilt;\n    if (!tiltOptions) {\n      return;\n    }\n    particle.tilt = {\n      enable: tiltOptions.enable,\n      value: degToRad(getRangeValue(tiltOptions.value)),\n      sinDirection: getRandom() >= half ? identity : -identity,\n      cosDirection: getRandom() >= half ? identity : -identity,\n      min: 0,\n      max: doublePI\n    };\n    let tiltDirection = tiltOptions.direction;\n    if (tiltDirection === TiltDirection.random) {\n      const index = Math.floor(getRandom() * double),\n        minIndex = 0;\n      tiltDirection = index > minIndex ? TiltDirection.counterClockwise : TiltDirection.clockwise;\n    }\n    switch (tiltDirection) {\n      case TiltDirection.counterClockwise:\n      case \"counterClockwise\":\n        particle.tilt.status = AnimationStatus.decreasing;\n        break;\n      case TiltDirection.clockwise:\n        particle.tilt.status = AnimationStatus.increasing;\n        break;\n    }\n    const tiltAnimation = particle.options.tilt?.animation;\n    if (tiltAnimation?.enable) {\n      particle.tilt.decay = identity - getRangeValue(tiltAnimation.decay);\n      particle.tilt.velocity = getRangeValue(tiltAnimation.speed) / maxAngle * this.container.retina.reduceFactor;\n      if (!tiltAnimation.sync) {\n        particle.tilt.velocity *= getRandom();\n      }\n    }\n  }\n  isEnabled(particle) {\n    const tiltAnimation = particle.options.tilt?.animation;\n    return !particle.destroyed && !particle.spawning && !!tiltAnimation?.enable;\n  }\n  loadOptions(options, ...sources) {\n    if (!options.tilt) {\n      options.tilt = new Tilt();\n    }\n    for (const source of sources) {\n      options.tilt.load(source?.tilt);\n    }\n  }\n  update(particle, delta) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!_this.isEnabled(particle) || !particle.tilt) {\n        return;\n      }\n      updateAnimation(particle, particle.tilt, false, DestroyType.none, delta);\n      yield Promise.resolve();\n    })();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}