{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/yoiker/Downloads/TechReboot2.58/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont } from \"@tsparticles/engine\";\nimport { drawEmoji } from \"./Utils.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"',\n  noPadding = 0;\nexport class EmojiDrawer {\n  constructor() {\n    this.validTypes = [\"emoji\"];\n    this._emojiShapeDict = new Map();\n  }\n  destroy() {\n    for (const [key, data] of this._emojiShapeDict) {\n      if (data instanceof ImageBitmap) {\n        data?.close();\n      }\n      this._emojiShapeDict.delete(key);\n    }\n  }\n  draw(data) {\n    const key = data.particle.emojiDataKey;\n    if (!key) {\n      return;\n    }\n    const image = this._emojiShapeDict.get(key);\n    if (!image) {\n      return;\n    }\n    drawEmoji(data, image);\n  }\n  init(container) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const options = container.actualOptions,\n        {\n          validTypes\n        } = _this;\n      if (!validTypes.find(t => isInArray(t, options.particles.shape.type))) {\n        return;\n      }\n      const promises = [loadFont(defaultFont)],\n        shapeOptions = validTypes.map(t => options.particles.shape.options[t]).find(t => !!t);\n      if (shapeOptions) {\n        executeOnSingleOrMultiple(shapeOptions, shape => {\n          if (shape.font) {\n            promises.push(loadFont(shape.font));\n          }\n        });\n      }\n      yield Promise.all(promises);\n    })();\n  }\n  particleDestroy(particle) {\n    particle.emojiDataKey = undefined;\n  }\n  particleInit(_container, particle) {\n    const double = 2,\n      shapeData = particle.shapeData;\n    if (!shapeData?.value) {\n      return;\n    }\n    const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData);\n    if (!emoji) {\n      return;\n    }\n    const emojiOptions = typeof emoji === \"string\" ? {\n        font: shapeData.font ?? defaultFont,\n        padding: shapeData.padding ?? noPadding,\n        value: emoji\n      } : {\n        font: defaultFont,\n        padding: noPadding,\n        ...shapeData,\n        ...emoji\n      },\n      font = emojiOptions.font,\n      value = emojiOptions.value;\n    const key = `${value}_${font}`;\n    if (this._emojiShapeDict.has(key)) {\n      particle.emojiDataKey = key;\n      return;\n    }\n    const padding = emojiOptions.padding * double,\n      maxSize = getRangeMax(particle.size.value),\n      fullSize = maxSize + padding,\n      canvasSize = fullSize * double;\n    let image;\n    if (typeof OffscreenCanvas !== \"undefined\") {\n      const canvas = new OffscreenCanvas(canvasSize, canvasSize),\n        context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = `400 ${maxSize * double}px ${font}`;\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(value, fullSize, fullSize);\n      image = canvas.transferToImageBitmap();\n    } else {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = canvasSize;\n      canvas.height = canvasSize;\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = `400 ${maxSize * double}px ${font}`;\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(value, fullSize, fullSize);\n      image = canvas;\n    }\n    this._emojiShapeDict.set(key, image);\n    particle.emojiDataKey = key;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}