{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/yoiker/Downloads/TechReboot2.56/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { errorPrefix } from \"@tsparticles/engine\";\nimport { replaceImageColor } from \"./Utils.js\";\nimport { drawGif } from \"./GifUtils/Utils.js\";\nconst double = 2,\n  defaultAlpha = 1,\n  sides = 12,\n  defaultRatio = 1;\nexport class ImageDrawer {\n  constructor(engine) {\n    var _this = this;\n    this.validTypes = [\"image\", \"images\"];\n    this.loadImageShape = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (imageShape) {\n        if (!_this._engine.loadImage) {\n          throw new Error(`${errorPrefix} image shape not initialized`);\n        }\n        yield _this._engine.loadImage({\n          gif: imageShape.gif,\n          name: imageShape.name,\n          replaceColor: imageShape.replaceColor ?? false,\n          src: imageShape.src\n        });\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this._engine = engine;\n  }\n  addImage(image) {\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    this._engine.images.push(image);\n  }\n  draw(data) {\n    const {\n        context,\n        radius,\n        particle,\n        opacity\n      } = data,\n      image = particle.image,\n      element = image?.element;\n    if (!image) {\n      return;\n    }\n    context.globalAlpha = opacity;\n    if (image.gif && image.gifData) {\n      drawGif(data);\n    } else if (element) {\n      const ratio = image.ratio,\n        pos = {\n          x: -radius,\n          y: -radius\n        },\n        diameter = radius * double;\n      context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n    }\n    context.globalAlpha = defaultAlpha;\n  }\n  getSidesCount() {\n    return sides;\n  }\n  init(container) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const options = container.actualOptions;\n      if (!options.preload || !_this2._engine.loadImage) {\n        return;\n      }\n      for (const imageData of options.preload) {\n        yield _this2._engine.loadImage(imageData);\n      }\n    })();\n  }\n  loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const imageData = particle.shapeData;\n    if (!imageData) {\n      return;\n    }\n    const image = this._engine.images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      void this.loadImageShape(imageData).then(() => {\n        this.loadShape(particle);\n      });\n    }\n  }\n  particleInit(container, particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const images = this._engine.images,\n      imageData = particle.shapeData;\n    if (!imageData) {\n      return;\n    }\n    const color = particle.getFillColor(),\n      image = images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      return;\n    }\n    const replaceColor = imageData.replaceColor ?? image.replaceColor;\n    if (image.loading) {\n      setTimeout(() => {\n        this.particleInit(container, particle);\n      });\n      return;\n    }\n    void _asyncToGenerator(function* () {\n      let imageRes;\n      if (image.svgData && color) {\n        imageRes = yield replaceImageColor(image, imageData, color, particle);\n      } else {\n        imageRes = {\n          color,\n          data: image,\n          element: image.element,\n          gif: image.gif,\n          gifData: image.gifData,\n          gifLoopCount: image.gifLoopCount,\n          loaded: true,\n          ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? defaultRatio,\n          replaceColor: replaceColor,\n          source: imageData.src\n        };\n      }\n      if (!imageRes.ratio) {\n        imageRes.ratio = 1;\n      }\n      const fill = imageData.fill ?? particle.shapeFill,\n        close = imageData.close ?? particle.shapeClose,\n        imageShape = {\n          image: imageRes,\n          fill,\n          close\n        };\n      particle.image = imageShape.image;\n      particle.shapeFill = imageShape.fill;\n      particle.shapeClose = imageShape.close;\n    })();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}