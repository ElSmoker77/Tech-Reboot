{"ast":null,"code":"import { Circle, Vector, clamp, getDistances } from \"@tsparticles/engine\";\nconst minFactor = 1,\n  identity = 1,\n  minRadius = 0;\nfunction processAttract(engine, container, position, attractRadius, area, queryCb) {\n  const attractOptions = container.actualOptions.interactivity.modes.attract;\n  if (!attractOptions) {\n    return;\n  }\n  const query = container.particles.quadTree.query(area, queryCb);\n  for (const particle of query) {\n    const {\n        dx,\n        dy,\n        distance\n      } = getDistances(particle.position, position),\n      velocity = attractOptions.speed * attractOptions.factor,\n      attractFactor = clamp(engine.getEasing(attractOptions.easing)(identity - distance / attractRadius) * velocity, minFactor, attractOptions.maxSpeed),\n      normVec = Vector.create(!distance ? velocity : dx / distance * attractFactor, !distance ? velocity : dy / distance * attractFactor);\n    particle.position.subFrom(normVec);\n  }\n}\nexport function clickAttract(engine, container, enabledCb) {\n  if (!container.attract) {\n    container.attract = {\n      particles: []\n    };\n  }\n  const {\n    attract\n  } = container;\n  if (!attract.finish) {\n    if (!attract.count) {\n      attract.count = 0;\n    }\n    attract.count++;\n    if (attract.count === container.particles.count) {\n      attract.finish = true;\n    }\n  }\n  if (attract.clicking) {\n    const mousePos = container.interactivity.mouse.clickPosition,\n      attractRadius = container.retina.attractModeDistance;\n    if (!attractRadius || attractRadius < minRadius || !mousePos) {\n      return;\n    }\n    processAttract(engine, container, mousePos, attractRadius, new Circle(mousePos.x, mousePos.y, attractRadius), p => enabledCb(p));\n  } else if (attract.clicking === false) {\n    attract.particles = [];\n  }\n}\nexport function hoverAttract(engine, container, enabledCb) {\n  const mousePos = container.interactivity.mouse.position,\n    attractRadius = container.retina.attractModeDistance;\n  if (!attractRadius || attractRadius < minRadius || !mousePos) {\n    return;\n  }\n  processAttract(engine, container, mousePos, attractRadius, new Circle(mousePos.x, mousePos.y, attractRadius), p => enabledCb(p));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}