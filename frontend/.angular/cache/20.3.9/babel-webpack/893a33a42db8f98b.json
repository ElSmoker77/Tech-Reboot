{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/maty_/Desktop/Tech-Reboot2.0/TechReboot/TechReboot/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { loadImage } from \"../Utils.js\";\nimport { InterlaceOffsets, InterlaceSteps } from \"./Constants.js\";\nimport { ByteStream } from \"./ByteStream.js\";\nimport { DisposalMethod } from \"./Enums/DisposalMethod.js\";\nimport { GIFDataHeaders } from \"./Types/GIFDataHeaders.js\";\nconst origin = {\n    x: 0,\n    y: 0\n  },\n  defaultFrame = 0,\n  half = 0.5,\n  initialTime = 0,\n  firstIndex = 0,\n  defaultLoopCount = 0;\nfunction parseColorTable(byteStream, count) {\n  const colors = [];\n  for (let i = 0; i < count; i++) {\n    colors.push({\n      r: byteStream.data[byteStream.pos],\n      g: byteStream.data[byteStream.pos + 1],\n      b: byteStream.data[byteStream.pos + 2]\n    });\n    byteStream.pos += 3;\n  }\n  return colors;\n}\nfunction parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n  switch (byteStream.nextByte()) {\n    case GIFDataHeaders.GraphicsControlExtension:\n      {\n        const frame = gif.frames[getFrameIndex(false)];\n        byteStream.pos++;\n        const packedByte = byteStream.nextByte();\n        frame.GCreserved = (packedByte & 0xe0) >>> 5;\n        frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n        frame.userInputDelayFlag = (packedByte & 2) === 2;\n        const transparencyFlag = (packedByte & 1) === 1;\n        frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n        const transparencyIndex = byteStream.nextByte();\n        if (transparencyFlag) {\n          getTransparencyIndex(transparencyIndex);\n        }\n        byteStream.pos++;\n        break;\n      }\n    case GIFDataHeaders.ApplicationExtension:\n      {\n        byteStream.pos++;\n        const applicationExtension = {\n          identifier: byteStream.getString(8),\n          authenticationCode: byteStream.getString(3),\n          data: byteStream.readSubBlocksBin()\n        };\n        gif.applicationExtensions.push(applicationExtension);\n        break;\n      }\n    case GIFDataHeaders.CommentExtension:\n      {\n        gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n        break;\n      }\n    case GIFDataHeaders.PlainTextExtension:\n      {\n        if (gif.globalColorTable.length === 0) {\n          throw new EvalError(\"plain text extension without global color table\");\n        }\n        byteStream.pos++;\n        gif.frames[getFrameIndex(false)].plainTextData = {\n          left: byteStream.nextTwoBytes(),\n          top: byteStream.nextTwoBytes(),\n          width: byteStream.nextTwoBytes(),\n          height: byteStream.nextTwoBytes(),\n          charSize: {\n            width: byteStream.nextTwoBytes(),\n            height: byteStream.nextTwoBytes()\n          },\n          foregroundColor: byteStream.nextByte(),\n          backgroundColor: byteStream.nextByte(),\n          text: byteStream.readSubBlocks()\n        };\n        break;\n      }\n    default:\n      byteStream.skipSubBlocks();\n      break;\n  }\n}\nfunction parseImageBlock(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _parseImageBlock.apply(this, arguments);\n}\nfunction _parseImageBlock() {\n  _parseImageBlock = _asyncToGenerator(function* (byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(),\n      localColorTableFlag = (packedByte & 0x80) === 0x80,\n      interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << (packedByte & 7) + 1;\n    if (localColorTableFlag) {\n      frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = index => {\n      const {\n        r,\n        g,\n        b\n      } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n      if (index !== getTransparencyIndex(null)) {\n        return {\n          r,\n          g,\n          b,\n          a: 255\n        };\n      }\n      return {\n        r,\n        g,\n        b,\n        a: avgAlpha ? ~~((r + g + b) / 3) : 0\n      };\n    };\n    const image = (() => {\n      try {\n        return new ImageData(frame.width, frame.height, {\n          colorSpace: \"srgb\"\n        });\n      } catch (error) {\n        if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n          return null;\n        }\n        throw error;\n      }\n    })();\n    if (image == null) {\n      throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(),\n      imageData = byteStream.readSubBlocksBin(),\n      clearCode = 1 << minCodeSize;\n    const readBits = (pos, len) => {\n      const bytePos = pos >>> 3,\n        bitPos = pos & 7;\n      return (imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16) & (1 << len) - 1 << bitPos) >>> bitPos;\n    };\n    if (interlacedFlag) {\n      for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\n        if (InterlaceOffsets[pass] < frame.height) {\n          let pixelPos = 0,\n            lineIndex = 0,\n            exit = false;\n          while (!exit) {\n            const last = code;\n            code = readBits(pos, size);\n            pos += size + 1;\n            if (code === clearCode) {\n              size = minCodeSize + 1;\n              dic.length = clearCode + 2;\n              for (let i = 0; i < dic.length; i++) {\n                dic[i] = i < clearCode ? [i] : [];\n              }\n            } else {\n              if (code >= dic.length) {\n                dic.push(dic[last].concat(dic[last][0]));\n              } else if (last !== clearCode) {\n                dic.push(dic[last].concat(dic[code][0]));\n              }\n              for (const item of dic[code]) {\n                const {\n                  r,\n                  g,\n                  b,\n                  a\n                } = getColor(item);\n                image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width + InterlaceSteps[pass] * lineIndex + pixelPos % (frame.width * 4));\n                pixelPos += 4;\n              }\n              if (dic.length === 1 << size && size < 0xc) {\n                size++;\n              }\n            }\n            if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n              lineIndex++;\n              if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\n                exit = true;\n              }\n            }\n          }\n        }\n        progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, {\n          x: frame.left,\n          y: frame.top\n        }, {\n          width: gif.width,\n          height: gif.height\n        });\n      }\n      frame.image = image;\n      frame.bitmap = yield createImageBitmap(image);\n    } else {\n      let code = 0,\n        size = minCodeSize + 1,\n        pos = 0,\n        pixelPos = -4,\n        exit = false;\n      const dic = [[0]];\n      while (!exit) {\n        const last = code;\n        code = readBits(pos, size);\n        pos += size;\n        if (code === clearCode) {\n          size = minCodeSize + 1;\n          dic.length = clearCode + 2;\n          for (let i = 0; i < dic.length; i++) {\n            dic[i] = i < clearCode ? [i] : [];\n          }\n        } else {\n          if (code === clearCode + 1) {\n            exit = true;\n            break;\n          }\n          if (code >= dic.length) {\n            dic.push(dic[last].concat(dic[last][0]));\n          } else if (last !== clearCode) {\n            dic.push(dic[last].concat(dic[code][0]));\n          }\n          for (const item of dic[code]) {\n            const {\n              r,\n              g,\n              b,\n              a\n            } = getColor(item);\n            image.data.set([r, g, b, a], pixelPos += 4);\n          }\n          if (dic.length >= 1 << size && size < 0xc) {\n            size++;\n          }\n        }\n      }\n      frame.image = image;\n      frame.bitmap = yield createImageBitmap(image);\n      progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, {\n        x: frame.left,\n        y: frame.top\n      }, {\n        width: gif.width,\n        height: gif.height\n      });\n    }\n  });\n  return _parseImageBlock.apply(this, arguments);\n}\nfunction parseBlock(_x7, _x8, _x9, _x0, _x1, _x10) {\n  return _parseBlock.apply(this, arguments);\n}\nfunction _parseBlock() {\n  _parseBlock = _asyncToGenerator(function* (byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch (byteStream.nextByte()) {\n      case GIFDataHeaders.EndOfFile:\n        return true;\n      case GIFDataHeaders.Image:\n        yield parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n        break;\n      case GIFDataHeaders.Extension:\n        parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n        break;\n      default:\n        throw new EvalError(\"undefined block found\");\n    }\n    return false;\n  });\n  return _parseBlock.apply(this, arguments);\n}\nexport function getGIFLoopAmount(gif) {\n  for (const extension of gif.applicationExtensions) {\n    if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n      continue;\n    }\n    return extension.data[1] + (extension.data[2] << 8);\n  }\n  return NaN;\n}\nexport function decodeGIF(_x11, _x12, _x13) {\n  return _decodeGIF.apply(this, arguments);\n}\nfunction _decodeGIF() {\n  _decodeGIF = _asyncToGenerator(function* (gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha) avgAlpha = false;\n    const res = yield fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n      throw new EvalError(\"file not found\");\n    }\n    const buffer = yield res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, {\n          colorSpace: \"srgb\"\n        }),\n        comments: [],\n        applicationExtensions: []\n      },\n      byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n      throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(),\n      globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << (packedByte & 7) + 1,\n      backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n      gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n      gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (() => {\n      try {\n        return new ImageData(gif.width, gif.height, {\n          colorSpace: \"srgb\"\n        });\n      } catch (error) {\n        if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n          return null;\n        }\n        throw error;\n      }\n    })();\n    if (backgroundImage == null) {\n      throw new Error(\"GIF frame size is to large\");\n    }\n    const {\n      r,\n      g,\n      b\n    } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\n      backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1,\n      incrementFrameIndex = true,\n      transparencyIndex = -1;\n    const getframeIndex = increment => {\n      if (increment) {\n        incrementFrameIndex = true;\n      }\n      return frameIndex;\n    };\n    const getTransparencyIndex = newValue => {\n      if (newValue != null) {\n        transparencyIndex = newValue;\n      }\n      return transparencyIndex;\n    };\n    try {\n      do {\n        if (incrementFrameIndex) {\n          gif.frames.push({\n            left: 0,\n            top: 0,\n            width: 0,\n            height: 0,\n            disposalMethod: DisposalMethod.Replace,\n            image: new ImageData(1, 1, {\n              colorSpace: \"srgb\"\n            }),\n            plainTextData: null,\n            userInputDelayFlag: false,\n            delayTime: 0,\n            sortFlag: false,\n            localColorTable: [],\n            reserved: 0,\n            GCreserved: 0\n          });\n          frameIndex++;\n          transparencyIndex = -1;\n          incrementFrameIndex = false;\n        }\n      } while (!(yield parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\n      gif.frames.length--;\n      for (const frame of gif.frames) {\n        if (frame.userInputDelayFlag && frame.delayTime === 0) {\n          gif.totalTime = Infinity;\n          break;\n        }\n        gif.totalTime += frame.delayTime;\n      }\n      return gif;\n    } catch (error) {\n      if (error instanceof EvalError) {\n        throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\n      }\n      throw error;\n    }\n  });\n  return _decodeGIF.apply(this, arguments);\n}\nexport function drawGif(data) {\n  const {\n      context,\n      radius,\n      particle,\n      delta\n    } = data,\n    image = particle.image;\n  if (!image?.gifData || !image.gif) {\n    return;\n  }\n  const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height),\n    offscreenContext = offscreenCanvas.getContext(\"2d\");\n  if (!offscreenContext) {\n    throw new Error(\"could not create offscreen canvas context\");\n  }\n  offscreenContext.imageSmoothingQuality = \"low\";\n  offscreenContext.imageSmoothingEnabled = false;\n  offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n  if (particle.gifLoopCount === undefined) {\n    particle.gifLoopCount = image.gifLoopCount ?? defaultLoopCount;\n  }\n  let frameIndex = particle.gifFrame ?? defaultFrame;\n  const pos = {\n      x: -image.gifData.width * half,\n      y: -image.gifData.height * half\n    },\n    frame = image.gifData.frames[frameIndex];\n  if (particle.gifTime === undefined) {\n    particle.gifTime = initialTime;\n  }\n  if (!frame.bitmap) {\n    return;\n  }\n  context.scale(radius / image.gifData.width, radius / image.gifData.height);\n  switch (frame.disposalMethod) {\n    case DisposalMethod.UndefinedA:\n    case DisposalMethod.UndefinedB:\n    case DisposalMethod.UndefinedC:\n    case DisposalMethod.UndefinedD:\n    case DisposalMethod.Replace:\n      offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n      context.drawImage(offscreenCanvas, pos.x, pos.y);\n      offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n      break;\n    case DisposalMethod.Combine:\n      offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n      context.drawImage(offscreenCanvas, pos.x, pos.y);\n      break;\n    case DisposalMethod.RestoreBackground:\n      offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n      context.drawImage(offscreenCanvas, pos.x, pos.y);\n      offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n      if (!image.gifData.globalColorTable.length) {\n        offscreenContext.putImageData(image.gifData.frames[firstIndex].image, pos.x + frame.left, pos.y + frame.top);\n      } else {\n        offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n      }\n      break;\n    case DisposalMethod.RestorePrevious:\n      {\n        const previousImageData = offscreenContext.getImageData(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n        context.drawImage(offscreenCanvas, pos.x, pos.y);\n        offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        offscreenContext.putImageData(previousImageData, origin.x, origin.y);\n      }\n      break;\n  }\n  particle.gifTime += delta.value;\n  if (particle.gifTime > frame.delayTime) {\n    particle.gifTime -= frame.delayTime;\n    if (++frameIndex >= image.gifData.frames.length) {\n      if (--particle.gifLoopCount <= defaultLoopCount) {\n        return;\n      }\n      frameIndex = firstIndex;\n      offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n    }\n    particle.gifFrame = frameIndex;\n  }\n  context.scale(image.gifData.width / radius, image.gifData.height / radius);\n}\nexport function loadGifImage(_x14) {\n  return _loadGifImage.apply(this, arguments);\n}\nfunction _loadGifImage() {\n  _loadGifImage = _asyncToGenerator(function* (image) {\n    if (image.type !== \"gif\") {\n      yield loadImage(image);\n      return;\n    }\n    image.loading = true;\n    try {\n      image.gifData = yield decodeGIF(image.source);\n      image.gifLoopCount = getGIFLoopAmount(image.gifData) ?? defaultLoopCount;\n      if (!image.gifLoopCount) {\n        image.gifLoopCount = Infinity;\n      }\n    } catch {\n      image.error = true;\n    }\n    image.loading = false;\n  });\n  return _loadGifImage.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}